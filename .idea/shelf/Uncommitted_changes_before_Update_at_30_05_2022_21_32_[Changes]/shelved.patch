Index: engine/data/data.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\r\n\r\n\r\nclass Data:\r\n    def __init__(self, folder: str):\r\n        self._folder = folder\r\n        self._tables = []  # list of tables:\r\n        self._parameters = []  # list of parameters\r\n\r\n    def get_tables(self):\r\n        return self._tables\r\n\r\n    def get_parameters(self):\r\n        return self._parameters\r\n\r\n    def folder(self):\r\n        return self._folder\r\n\r\n    def table_folder(self):  # returns path to tables\r\n        return f'{self.folder()}\\\\tables'\r\n\r\n    def parameter_folder(self):   # returns path to tables\r\n        return f'{self.folder()}\\\\parameters'\r\n\r\n    def add_table(self, table_: Table):\r\n        self._tables.append(table_)\r\n        table_.to_csv(self.table_folder())\r\n\r\n    def add_parameter(self, parameter: Parameter):\r\n        self._parameters.append(parameter)\r\n        parameter.to_json(self.parameter_folder())\r\n\r\n    def _read_tables(self):\r\n        path = self.table_folder()\r\n        files = os.listdir(path=path)\r\n        current_directory = os.getcwd()\r\n        os.chdir(path)\r\n        for file in files:\r\n            if not file.endswith('.json'):\r\n                continue\r\n            with open(file, 'r', encoding='utf8') as f:\r\n                data = json.load(f)\r\n            for name in data.keys():\r\n                self._tables.append(\r\n                    Table.init_from_file(name, data[name])\r\n                )\r\n        os.chdir(current_directory)\r\n\r\n    def _read_parameters(self):\r\n        path = self.parameter_folder()\r\n        files = os.listdir(path=path)\r\n        current_directory = os.getcwd()\r\n        os.chdir(path)\r\n        for file in files:\r\n            with open(file, 'r', encoding='utf8') as f:\r\n                data = json.load(f)\r\n            for name in data.keys():\r\n                self._parameters.append(\r\n                    Parameter.init_from_file(name, data[name])\r\n                )\r\n        os.chdir(current_directory)\r\n\r\n\r\nclass DataSource(Data):\r\n    def __init__(self, folder: str):\r\n        super(DataSource, self).__init__(folder)\r\n        self._read_tables()\r\n        self._read_parameters()\r\n\r\n\r\nclass DataResult(Data):\r\n    def __init__(self, folder: str):\r\n        super().__init__(folder)\r\n        self._images = []\r\n        self._texts = []\r\n        self.__read_texts()\r\n\r\n    def image_folder(self):\r\n        return f'{self.folder()}\\\\images'\r\n\r\n    def get_images(self):\r\n        return self._images\r\n\r\n    def add_image(self, image: fig):\r\n        pass\r\n\r\n    def __read_texts(self):\r\n        pass\r\n\r\n\r\nclass DataMaterial(Data):\r\n    def __init__(self, folder: str):\r\n        super(DataMaterial, self).__init__(folder)\r\n        self._read_tables()\r\n        self._read_parameters()\r\n\r\n\r\nclass DataController:\r\n    def __init__(self, lab: str):\r\n        self.lab = lab\r\n        self.__generate_data()\r\n\r\n    def __generate_data(self):\r\n        source_folder = f'..\\\\..\\\\sources\\\\{self.lab}'\r\n        self.source = DataSource(source_folder)\r\n\r\n        material_folder = f'..\\\\..\\\\materials\\\\{self.lab}'\r\n        self.material = DataMaterial(material_folder)\r\n\r\n        result_folder = f'..\\\\..\\\\results\\\\{self.lab}'\r\n        self.result: DataResult = DataResult(result_folder)\r\n\r\n\r\ndc = DataController('lab_111')\r\nd = dc.material.get_parameters()[0]\r\nD = dc.material.get_parameters()[1]\r\nN = dc.material.get_parameters()[3]\r\nprint(d)\r\nprint(D)\r\nprint(N)\r\ndDd = d * D * d\r\nprint(dDd)\r\ndDd >> 3\r\nprint(dDd)\r\nunit = dDd.get_unit_numerator()[0]\r\ndDd.set_prefix(unit, 'm')\r\nprint(dDd)\r\ndDd.set_prefix(unit, 'M')\r\nprint(dDd)\r\ndDd << 2\r\nprint(dDd)\r\nprint(d)\r\nprint(D)\r\nDN = N / D ** 2\r\nDN >> 5\r\nprint(DN)\r\nk = N / 5\r\nprint(k)\r\nprint('All is good')\r\n\r\n\r\n# testing Tables:\r\ntable = dc.source.get_tables()[0]\r\n\r\nprint(table)\r\nprint(table.keys())\r\ntable['R_ev'] = d\r\ntable['R'][3] = D\r\ntable['R_ev'][3] *= 2\r\ntable['R_ev'] *= table['R'][3]\r\nprint(table)\r\nprint()\r\nprint(table.iloc[2])\r\nprint()\r\n\r\n\r\ntable1 = dc.material.get_tables()[0]\r\nprint(table1)\r\ntable1.insert(2, '12321', table['R_ev'])\r\nprint(table1)\r\n\r\nprint('All is good')\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/engine/data/data.py b/engine/data/data.py
--- a/engine/data/data.py	(revision 013297580a093e4c7ea7943c4c51f93fe26693c9)
+++ b/engine/data/data.py	(date 1653935212284)
@@ -1,6 +1,3 @@
-
-
-
 class Data:
     def __init__(self, folder: str):
         self._folder = folder
Index: engine/data/measunit.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from __future__ import annotations\r\n\r\n\r\n\r\n# the entity specifying the multiplier and the simple prefix string\r\nclass Prefix:\r\n    def __init__(self, prefix: str | int | Prefix):\r\n        # for example:\r\n        # Prefix('mk') or Prefix ('micro')\r\n        if type(prefix) == Prefix:\r\n            self.__prefix = prefix.__prefix\r\n            self.__multiplier = prefix.__multiplier\r\n        elif type(prefix) in (int, float):\r\n            if prefix in Prefix.__multipliers.keys():\r\n                full_name_of_prefix = Prefix.__multipliers[prefix]\r\n                self.__prefix = Prefix.__prefixes[full_name_of_prefix]\r\n                self.__multiplier = Prefix.__prefixes[full_name_of_prefix][0]\r\n            else:\r\n                self.__prefix = [prefix, f'10^{prefix} ', f'10^{prefix} ']\r\n                self.__multiplier = prefix\r\n        else:\r\n            if prefix in Prefix.__en_prefixes.keys():\r\n                full_name_of_prefix = Prefix.__en_prefixes[prefix]\r\n            elif prefix in Prefix.__ru_prefixes.keys():\r\n                full_name_of_prefix = Prefix.__ru_prefixes[prefix]\r\n            elif prefix in Prefix.__prefixes.keys():\r\n                full_name_of_prefix = prefix\r\n            else:\r\n                raise RuntimeError(f'incorrect prefix: {prefix}')\r\n            self.__prefix = Prefix.__prefixes[full_name_of_prefix]\r\n            self.__multiplier = Prefix.__prefixes[full_name_of_prefix][0]\r\n\r\n    def get_prefix_string(self, language='en'):\r\n        if language == 'en':\r\n            return self.__prefix[2]\r\n        elif language == 'ru':\r\n            return self.__prefix[1]\r\n        raise RuntimeError(f\"incorrect language: {language}\\n\"\r\n                           f\"(accessible: 'en' or 'ru', not {language})\")\r\n\r\n    def get_multiplier(self):\r\n        return self.__multiplier\r\n\r\n    # load list of prefixes dictionaries from file. Example:\r\n    # \"micro\": [-6, \"мк\", \"mk\"] etc.\r\n    with open('units.json', 'r', encoding='utf8') as f:\r\n        data = json.load(f)\r\n        __prefixes = data['prefix']  # key - full name of prefix\r\n        __en_prefixes = dict()  # key - short EN name of prefix\r\n        __ru_prefixes = dict()  # key - short RU name of prefix\r\n        __multipliers = dict()  # key - the degree of prefix\r\n        for current_prefix in data['prefix'].keys():\r\n            __en_prefixes[data['prefix'][current_prefix][2]] = current_prefix\r\n            __ru_prefixes[data['prefix'][current_prefix][1]] = current_prefix\r\n            __multipliers[data['prefix'][current_prefix][0]] = current_prefix\r\n\r\n    def __mul__(self, other: Prefix):\r\n        return Prefix(self.get_multiplier() + other.get_multiplier())\r\n\r\n    def __truediv__(self, other: Prefix):\r\n        return Prefix(self.get_multiplier() - other.get_multiplier())\r\n\r\n    def __str__(self):\r\n        return f'{self.get_prefix_string()} | {self.get_multiplier()}'\r\n\r\n    def __repr__(self):\r\n        return str(self)\r\n\r\n\r\nclass MeasUnit:\r\n    @staticmethod\r\n    def init_from_file(data):\r\n        type_of_unit = data[0]\r\n        dataset = data[1:]\r\n        base = MeasUnit.Fraction.base.value\r\n        derived = MeasUnit.Fraction.derived.value\r\n        numerator = MeasUnit.Fraction.numerator.value\r\n        denominator = MeasUnit.Fraction.denominator.value\r\n\r\n        if type_of_unit == base:\r\n            base_unit = BaseMeasUnit.init_from_tokens(*dataset)\r\n            d = {\r\n                numerator: [base_unit],\r\n                denominator: []\r\n            }\r\n            return DerivedMeasUnit(\r\n                base_unit.get_symbol(),\r\n                base_unit.get_category(),\r\n                **d\r\n            )\r\n        elif type_of_unit == derived:\r\n            return DerivedMeasUnit.init_from_tokens(*dataset)\r\n        else:\r\n            raise RuntimeError(f'incorrect type of unit to init: {type_of_unit}')\r\n\r\n    with open('units.json', 'r', encoding='utf8') as f:\r\n        derived_units = json.load(f)['derived_units']\r\n\r\n    with open('units.json', 'r', encoding='utf8') as f:\r\n        base_units = json.load(f)['base_units']\r\n\r\n    with open('units.json', 'r', encoding='utf8') as f:\r\n        constants = json.load(f)['constants']\r\n\r\n    class Fraction(enum.Enum):\r\n        numerator = 'numerator'\r\n        denominator = 'denominator'\r\n        base = 'base'\r\n        derived = 'derived'\r\n\r\n\r\n# the unit of derived_unit with particular prefixes and degree\r\n# Examples:\r\n#   (m) || (mm) || (s) || (sm)^2\r\n# P.S. you can see list of base_units in \"units.json\\base_units\"\r\nclass BaseMeasUnit:\r\n    @classmethod\r\n    def init_from_tokens(\r\n            cls,\r\n            category: str,\r\n            prefix: str,\r\n            degree: int):\r\n        return cls(prefix, category, degree)\r\n\r\n    @classmethod\r\n    def copy(cls, unit: BaseMeasUnit):\r\n        prefix = unit.get_prefix().get_multiplier()\r\n        category = unit.get_category()\r\n        degree = unit.get_degree()\r\n        return BaseMeasUnit(prefix, category, degree)\r\n\r\n    def __init__(self,\r\n                 prefix: str | int | Prefix,\r\n                 category: str,\r\n                 degree: int = 1,\r\n                 multiplier: int = 0):\r\n        data = MeasUnit.base_units[category]\r\n        self.__category = category\r\n        self.__symbol = data[0]\r\n        self.__unit = data[1]\r\n        self.__degree = degree * data[2]\r\n        self.__prefix = Prefix('')\r\n        self.__multiplier = multiplier\r\n        self.set_prefix(prefix)\r\n\r\n    def get_degree(self):\r\n        return self.__degree\r\n\r\n    def get_prefix(self):\r\n        return self.__prefix\r\n\r\n    def get_multiplier(self):\r\n        return self.__multiplier\r\n\r\n    def get_symbol(self):\r\n        return self.__symbol\r\n\r\n    def get_category(self):\r\n        return self.__category\r\n\r\n    def set_prefix(self, prefix: str | int | Prefix):\r\n        prev_pref_mult = self.get_prefix().get_multiplier()\r\n        self.__prefix = Prefix(prefix)\r\n        n = prev_pref_mult - self.get_prefix().get_multiplier()\r\n        self.__update_multiplier(n)\r\n\r\n    def set_degree(self, n: float):\r\n        self.__degree = n\r\n        self.__multiplier = -self.get_multiplier()\r\n\r\n    def to_si(self):\r\n        if self.get_category() == 'mass':\r\n            self.set_prefix('kilo')\r\n        else:\r\n            self.set_prefix(\"\")\r\n\r\n    def __update_multiplier(self, n: int = None):\r\n        if n is None:\r\n            n = self.get_prefix().get_multiplier()\r\n        self.__multiplier = self.get_multiplier() + n * self.__degree\r\n\r\n    def __get_flipped(self):\r\n        unit = BaseMeasUnit.copy(self)\r\n        unit.set_degree(-unit.get_degree())\r\n        return unit\r\n\r\n    def __str__(self):\r\n        s = ''\r\n        # if self.get_multiplier() == 0:\r\n        #     s = ''\r\n        # else:\r\n        #     s = f'10^[{self.get_multiplier()}] * '\r\n        s = f'{s}{self.__prefix.get_prefix_string()}{self.__unit}'\r\n        if self.get_degree() == 1:\r\n            return s\r\n        elif self.get_degree() == 0:\r\n            return ''\r\n        return f'{s}^[{self.get_degree()}]'\r\n\r\n    def __repr__(self):\r\n        return str(self)\r\n\r\n    def __mul__(self, other: BaseMeasUnit):\r\n        if self != other:\r\n            raise RuntimeError(f'incorrect categories of multipliers')\r\n        degree = self.get_degree() + other.get_degree()\r\n        category = self.get_category()\r\n        multiplier = self.get_multiplier() + other.get_multiplier()\r\n        return BaseMeasUnit(Prefix(''), category, degree, multiplier)\r\n\r\n    def __pow__(self, power: float):\r\n        prefix = self.get_prefix()\r\n        category = self.get_category()  # !&&!&!&!&!&!&^!@#%%@!$&TGU!FYDFUI !I\r\n        degree = self.get_degree() * power\r\n        unit = BaseMeasUnit(prefix, category, degree)\r\n        return unit\r\n\r\n    def __truediv__(self, other: BaseMeasUnit):\r\n        other = other.__get_flipped()\r\n        return self * other\r\n\r\n    def __eq__(self, other: BaseMeasUnit):\r\n        return self.get_category() == other.get_category()\r\n\r\n    def __ne__(self, other: BaseMeasUnit):\r\n        return not self == other\r\n\r\n\r\n# the unit of derived_unit with particular prefixes\r\n# Examples:\r\n#   (m)/(s^2) || (mm)/(s^2),\r\n#   (J) || (kg*m^2)/(s^2) <- physical work бирююююк\r\nclass DerivedMeasUnit:\r\n    @classmethod\r\n    def init_from_tokens(\r\n            cls,\r\n            category: str,\r\n            index: int,\r\n            prefixes: list):\r\n        numerator = MeasUnit.Fraction.numerator.value\r\n        denominator = MeasUnit.Fraction.denominator.value\r\n        unit = MeasUnit.derived_units[category]\r\n        symbol = unit[0]\r\n        template = unit[1][index]\r\n        if numerator not in template.keys():\r\n            raise RuntimeError(f\"can't find key: {numerator}\")\r\n        if denominator not in template.keys():\r\n            raise RuntimeError(f\"can't find key: {denominator}\")\r\n\r\n        def __generate_base_units(prefixes_, units):\r\n            a = []\r\n            for i in range(len(units)):\r\n                category_ = units[i][0]\r\n                degree_ = units[i][1]\r\n                a.append(BaseMeasUnit(\r\n                    prefixes_[i],\r\n                    category_,\r\n                    degree_))\r\n            return a\r\n\r\n        sp1 = template[numerator]\r\n        sp2 = template[denominator]\r\n        l1 = len(sp1)\r\n        numer = __generate_base_units(prefixes[:l1], sp1)\r\n        denom = __generate_base_units(prefixes[l1:], sp2)\r\n        d = {\r\n            numerator: numer,\r\n            denominator: denom\r\n        }\r\n        return cls(symbol, category, **d)\r\n\r\n    @classmethod\r\n    def copy(cls, unit: DerivedMeasUnit):\r\n        numerator = MeasUnit.Fraction.numerator.value\r\n        denominator = MeasUnit.Fraction.denominator.value\r\n        symbol = unit.get_symbol()\r\n        category = unit.get_category()\r\n        units = {numerator: [],\r\n                 denominator: []}\r\n        for un in unit.get_units()[numerator]:\r\n            units[numerator].append(BaseMeasUnit.copy(un))\r\n        for un in unit.get_units()[denominator]:\r\n            units[denominator].append(BaseMeasUnit.copy(un))\r\n        return cls(symbol, category, **units)\r\n\r\n    def __init__(self, symbol: str, category: str, **units):\r\n        numerator = MeasUnit.Fraction.numerator.value\r\n        denominator = MeasUnit.Fraction.denominator.value\r\n        self.__category = category\r\n        self.__numerator = units[numerator]  # list if Kinds\r\n        self.__denominator = units[denominator]  # list if Kinds\r\n        self.__symbol = symbol\r\n        self.__multiplier = 0\r\n        self.__rel_multiplier = 0\r\n        self.__update_multipliers(save_rel_multiplier=True)\r\n\r\n    def get_units(self):\r\n        numerator = MeasUnit.Fraction.numerator.value\r\n        denominator = MeasUnit.Fraction.denominator.value\r\n        d = {\r\n            numerator: self.numerator(),\r\n            denominator: self.denominator()\r\n        }\r\n        return d\r\n\r\n    def numerator(self):\r\n        return self.__numerator\r\n\r\n    def denominator(self):\r\n        return self.__denominator\r\n\r\n    def get_multiplier(self):\r\n        return self.__multiplier\r\n\r\n    def get_rel_multiplier(self):\r\n        return self.__rel_multiplier\r\n\r\n    def get_symbol(self):\r\n        return self.__symbol\r\n\r\n    def get_category(self):\r\n        return self.__category\r\n\r\n    def set_prefix(self, unit: BaseMeasUnit, prefix: str):\r\n        if unit in self.numerator():\r\n            i = self.numerator().index(unit)\r\n            self.__numerator[i].set_prefix(prefix)\r\n        elif unit in self.denominator():\r\n            i = self.denominator().index(unit)\r\n            self.__denominator[i].set_prefix(prefix)\r\n        else:\r\n            raise RuntimeError(f\"\"\"No such unit ({str(unit)}) in {str(self)}\"\"\")\r\n        self.__update_multipliers()\r\n\r\n    def to_si(self):\r\n        for unit in self.numerator():\r\n            unit.to_si()\r\n        for unit in self.__denominator:\r\n            unit.to_si()\r\n        self.__update_multipliers()\r\n\r\n    def __get_flipped(self):\r\n        unit = DerivedMeasUnit.copy(self)\r\n        unit.__denominator, unit.__numerator = unit.__numerator, unit.__denominator\r\n        return unit\r\n\r\n    def __find_unit_in_fraction(self, unit: BaseMeasUnit):\r\n        numerator = MeasUnit.Fraction.numerator.value\r\n        denominator = MeasUnit.Fraction.denominator.value\r\n        numer = self.numerator()\r\n        denom = self.denominator()\r\n        for i in range(len(numer)):\r\n            if numer[i].get_category() == unit.get_category():\r\n                return numerator, i\r\n        for i in range(len(denom)):\r\n            if denom[i].get_category() == unit.get_category():\r\n                return denominator, i\r\n        return False\r\n\r\n    def __update_multipliers(self, save_rel_multiplier=False):\r\n        multiplier = 0\r\n        for unit in self.numerator():\r\n            multiplier += unit.get_multiplier()\r\n        for unit in self.denominator():\r\n            multiplier -= unit.get_multiplier()\r\n        if not save_rel_multiplier:\r\n            self.__rel_multiplier += multiplier - self.__multiplier\r\n        self.__multiplier = multiplier\r\n\r\n    def __str__(self):\r\n        if not self.numerator() and not self.denominator():\r\n            return 'unit'\r\n        if not self.denominator():\r\n            return '*'.join(str(i) for i in self.numerator())\r\n        if not self.numerator():\r\n            return '[-1]*'.join(str(i) for i in self.numerator()) + '[-1]'\r\n        s1 = '*'.join(str(i) for i in self.numerator())\r\n        s2 = '*'.join(str(i) for i in self.denominator())\r\n        return f'({s1})/({s2})'\r\n\r\n    def __repr__(self):\r\n        return str(self)\r\n\r\n    def __mul__(self, other: DerivedMeasUnit):\r\n        new_unit = DerivedMeasUnit.copy(self)\r\n        numerator = MeasUnit.Fraction.numerator.value\r\n        other_numer = other.numerator()\r\n        other_denom = other.denominator()\r\n        for i in range(len(other_numer)):\r\n            find = new_unit.__find_unit_in_fraction(other_numer[i])\r\n            if find:\r\n                part = find[0]\r\n                index = find[1]\r\n                if part == numerator:\r\n                    new_unit.__numerator[index] = new_unit.__numerator[index] * other_numer[i]\r\n                else:\r\n                    new_unit.__denominator[index] = new_unit.__denominator[index] / other_numer[i]\r\n            else:\r\n                new_unit.__numerator.append(other_numer[i])\r\n        for i in range(len(other_denom)):\r\n            find = new_unit.__find_unit_in_fraction(other_denom[i])\r\n            if find:\r\n                part = find[0]\r\n                index = find[1]\r\n                if part == numerator:\r\n                    new_unit.__numerator[index] = new_unit.__numerator[index] / other_denom[i]\r\n                else:\r\n                    new_unit.__denominator[index] = new_unit.__denominator[index] * other_denom[i]\r\n            else:\r\n                new_unit.__denominator.append(other_denom[i])\r\n        new_unit.__update_multipliers(save_rel_multiplier=True)\r\n        return new_unit\r\n\r\n    def __pow__(self, power: float):\r\n        unit = DerivedMeasUnit.copy(self)\r\n        numer = unit.numerator()\r\n        denom = unit.denominator()\r\n        numer_buf = []\r\n        denom_buf = []\r\n        for i in range(len(numer)):\r\n            new_unit = numer[i] ** power\r\n            if new_unit.get_degree() < 0:\r\n                new_unit.set_degree(-new_unit.get_degree())\r\n                del numer[i]\r\n                denom_buf.append(new_unit)\r\n            else:\r\n                numer[i] = new_unit\r\n        for i in range(len(denom)):\r\n            new_unit = denom[i] ** power\r\n            if new_unit.get_degree() < 0:\r\n                new_unit.set_degree(-new_unit.get_degree())\r\n                del denom[i]\r\n                numer_buf.append(new_unit)\r\n            else:\r\n                denom[i] = new_unit\r\n        numer.extend(numer_buf)\r\n        denom.extend(denom_buf)\r\n        return unit\r\n\r\n    def __truediv__(self, other: DerivedMeasUnit):\r\n        other = other.__get_flipped()\r\n        return self * other\r\n\r\n    def __eq__(self, other: DerivedMeasUnit):\r\n        numer_1 = set(unit.get_category for unit in self.numerator())\r\n        denom_1 = set(unit.get_category for unit in self.denominator())\r\n        numer_2 = set(unit.get_category for unit in other.numerator())\r\n        denom_2 = set(unit.get_category for unit in other.denominator())\r\n        return numer_1 == numer_2 and denom_1 == denom_2\r\n\r\n    def __ne__(self, other: DerivedMeasUnit):\r\n        return not self == other\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/engine/data/measunit.py b/engine/data/measunit.py
--- a/engine/data/measunit.py	(revision 013297580a093e4c7ea7943c4c51f93fe26693c9)
+++ b/engine/data/measunit.py	(date 1653935548585)
@@ -1,7 +1,6 @@
 from __future__ import annotations
 
 
-
 # the entity specifying the multiplier and the simple prefix string
 class Prefix:
     def __init__(self, prefix: str | int | Prefix):
